# Лабораторная работа №5
# Ошибка 1 — неправильный разбор строки


## Место
`simulation.py`, функция `generate_random_year`, строка 59

## Симптом
Проверка `if year_str[2:4] == "00":` может вести себя некорректно для:
Года "800" → `year_str` = "800" → `year_str[2:4]` = "0" (индекс 4 вне диапазона)

## Как воспроизвести
1. Запустить симуляцию и поймать год меньше 1000, кратный 100
## Отладка
Установлен breakpoint на функции

**Наблюдения:**
При 800 году берется неправильный срез, который выходит за рамки строки, поэтому результат получается неверным

**Проблема:** Логика предполагает, что год всегда 4-значный, но `random.randint(0, 2024)` не всегда возвращает 4-значные числа.
## Причина
Использование жёстко закодированных индексов без проверки длины строки, это антипаттерн.

**Уязвимый код:**
```python
year_str = str(random.randint(0, 2024))
if year_str[2:4] == "00":  # Предполагает, что year_str длиной минимум 4
```

## Исправление
```python
year = random.randint(0, 2024)
if year % 100 == 0:  # Год, оканчивающийся на 00
    return (year + 10)
return year
```

## Проверка
Поведение симуляции соответствует ожидаемому.

## Доказательства
### 1. Скриншот нерабочего кода

![нерабочий](screenshots/img1_incorrect.png)

### 2. Скриншот исправленной логики
![рабочий](screenshots/img1_correct.png)

# Ошибка 2 — перехват слишком общего исключения

## Место
`main.py`, функция `main()`, строка 19

## Симптом
Программа неправильно обрабатывает некорректный ввод seed. Если пользователь введёт нецелое число для seed (например, "abc"), программа выведет общее сообщение "Ошибка: введите целое число" и завершится, но также завершится, если ввод будет некорректным только для seed, даже если steps был введён корректно.

## Как воспроизвести
1. Запустить симуляцию
2. Ввести корректное количество шагов
3. Ввести некорректный seed
4. Наблюдать:
   ```
   Ошибка: введите целое число
   ```
   Программа завершается, хотя steps был введён корректно.

## Отладка
Установлен breakpoint на строке 19 (`except ValueError:`):

**Наблюдения в отладчике:**
- При вводе `steps_input = "10"` → `steps = 10` (корректно)
- При вводе `seed_input = "abc"` → `int("abc")` вызывает `ValueError`
- Исключение перехватывается общим обработчиком
- Программа завершается, не запуская симуляцию

**Проблема:** Один обработчик исключений перехватывает ошибки как от `steps`, так и от `seed`, хотя это разные этапы ввода.

## Причина
Использование общего блока `try-except` для двух независимых операций преобразования строк в числа. Если ошибка происходит при преобразовании seed, программа завершается, даже если steps был введён корректно.

**Ошибочный код:**
```python
try:
    steps_input = input("Введите количество шагов симуляции (по умолчанию 20): ").strip()
    if steps_input:
        steps = int(steps_input)
        if steps <= 0:
            print("Количество шагов должно быть положительным числом")
            return
    else:
        steps = 20
    
    seed_input = input("Введите seed для генератора случайных чисел (опционально, Enter для пропуска): ").strip()
    seed = int(seed_input) if seed_input else None
except ValueError:
    print("Ошибка: введите целое число")
    return
```

## Исправление
```python
def main() -> None:
    steps_input = input("Введите количество шагов симуляции (по умолчанию 20): ").strip()
    if steps_input:
        try:
            steps = int(steps_input)
            if steps <= 0:
                print("Количество шагов должно быть положительным числом")
                return
        except ValueError:
            print("Ошибка: введите целое число для количества шагов")
            return
    else:
        steps = 20
    
    seed_input = input("Введите seed для генератора случайных чисел (опционально, Enter для пропуска): ").strip()
    if seed_input:
        try:
            seed = int(seed_input)
        except ValueError:
            print("Ошибка: введите целое число для seed или оставьте пустым")
            return
    else:
        seed = None
    
    run_simulation(steps=steps, seed=seed)
```

## Проверка
После исправления:

**Тест 1: Некорректный seed при корректном steps**
```
Введите количество шагов симуляции (по умолчанию 20): 10
Введите seed для генератора случайных чисел (опционально, Enter для пропуска): abc
Ошибка: введите целое число для seed или оставьте пустым
```

## Доказательства

### 1. Скриншот неправильной версии
![неисправлено](screenshots/img2_incorrect.png)

### 2. Скриншот исправленной версии
![исправлено](screenshots/img2_correct.png)

# Ошибка 3 — сравнение через `is` вместо `==` для строк

## Место
`simulation.py`, функция `generate_random_genre()`, строка 39

## Симптом
Когда функция выбирает жанр "Роман", она должна добавлять к нему "Исторический", но этого не происходит. Жанр "Роман" всегда возвращается без модификации.

## Как воспроизвести
1. Запустить симуляцию с фиксированным seed для предсказуемости:
2. Наблюдать вывод событий поиска по жанру:
   Никогда не видим: `'Историчекий роман'`

## Отладка
Установлен breakpoint на функции

**Наблюдения в отладчике:**
- `genre = "Роман"` (значение)
- `genre is "Роман"` возвращает `False` (ошибка!)
- `genre == "Роман"` возвращает `True` (правильно)
- `id(genre)` и `id("Роман")` разные
- Выполнение всегда пропускает ветку `if`

## Причина
Использование оператора `is` для сравнения значений строк. Оператор `is` проверяет идентичность объектов в памяти, а не равенство их значений. Строка `"Роман"`, возвращаемая `random.choice()`, и строковый литерал `"Роман"` в условии - разные объекты в памяти.

**Ошибочный код:**
```python
genre = random.choice(genres)
if genre is "Роман":
    return "Исторический роман"
return genre
```

## Исправление
```python
genre = random.choice(genres)
if genre == "Роман":
    return "Исторический роман"
return genre
```

## Доказательства

### 1. Скриншот статистики до исправления
![неправильно](screenshotы/img3_incorrect.png)

### 2. Скриншот исправленного условия в коде
![правильно](screenshotы/img3_correct.png)

---
